# 正向代理
  类似 vpn,用户需要线连接 vpn,再通过 vpn 访问服务器
# 反向代理
  用户发起请求被反向服务器接收到,再由服务器决定转发给某个具体的服务.反向服务器决定了客户端最终访问到的目标服务器.
# 浏览器同源策略
  为了保证 html 安全性, 协议+域名+端口三者相同.ip 无效
  限制了 cookie localStorage读取
  Dom js 对象无法获得
  ajax 请求
  ## Cookie 的同源策略
  Domain 和 Path 来指示 Cookie 的作用域/
  Domain 告诉浏览器当前添加 Cookie 的域名归属,没有明确指明默认当前域名.
  Path 告诉浏览器当前添加 Cookie 的路径归属,没有明确指明默认当前路径.

# 跨域解决方案
1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS） Access-Control-Allow-Origin
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域


# 跨域请求头设置
Access-Control-Allow-Origin: * 或者允许的地址
Access-Control-Allow-Methods: POST,GET(* 严格模式会报错)
Access-Control-Allow-Headers: Origin,Content-Type,Accept,token,X-Requested-With
## Cookie 跨域携带?
设置 withCredentials:true. 且 Access-Control-Allow-Origin不能设置为'*'.
SameSite 用来限制第三方 Cookie,从而减少安全风险.Chrome默认 Lax
1. strict 浏览器只发送相同站点请求 Cookie
2. Lax 允许部分第三方请求携带 Cookie
3. None 无论跨站都会发送 cookie
设置 Cookie 强行把 SameSite 设置为 None,但是 Secure 属性必须开启(支持 Https).
部分浏览器不支持设置,需要通过 UA 判断

# 浏览器多进程架构
 1.浏览器进程
 2.渲染进程
 3.插件进程
 4.GPU进程
 优点: 
  渲染进程出问题不会影响其他进程
 缺点:
  不同进程间内存不共享
# 常见http 请求码
101 当websocket使用时
2xx 成功处理了请求的状态码
  200 服务器成功处理了请求
  201 请求成功并且服务器创建了新的资源
  202 服务器接收请求,但尚未处理
  203 服务器成功处理了请求,单返回的信息来自另一来源
  204 （无内容）服务器成功处理了请求，但没有返回任何内容
  205 （重置内容） 服务器成功处理了请求，但没有返回任何内容
  206 （部分内容） 服务器成功处理了部分 GET 请求
  
3xx 完成请求,需要进一步操作.通常用来重定向
  300   返回一个有多个连接选项的页面,用户自行选择从定向
  301 （永久移动）请求的页面已永久移动到新位置,之后会自动将请求转到新位置。浏览器会做缓存重定向
  302 （临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
  303  临时重定向 http1.1 状态码 发送 post 请求收到后,重定向为 get 请求,不需要向用户确认
  304 （未修改）自从上次请求后,页面没有修改过.使用缓存
  305 （使用代理）请求者只能用代理访问请求的页面.
  307 临时重定向,http1.1 状态码,询问用户是否再次 post

4xx 客户端出现错误
  401 没有提供认证信息
  403 没有权限
  404 内容不存在
  405 请求方法不被允许


5xx 服务器出现错误
  500 服务器错误
  502 网关错误
  503 展示不可用

# cookie 与 storage、session、jwt 区别
## cookie
  cookie 可以自动携带在同源的 http请求中,数据大小不能超过 4k,在设置过期时间前一直有效,在所有同源窗口中共享.
  cookie 属性:Name, Value, Domain, Path, Expires/Max-Age, Size, HttpOnly, Secure, SameSite.
  标记为Secure的 cookie 只能被 https 协议加密过的请求发送给服务端.但也无法保证其安全到达.
  SameSite: 允许服务器要求某个 cookie 在跨站请求时不会被发送,从而阻止 CSRF.
## Session
  表示是 c/s架构中服务器和客户端一次会话的过程,用来保存认证用户信息.Session 是一种 HTTP 储存机制,提供持久机制.Session 存放在服务器端,用来验证客户端信息.
## JWT
  JSON Web Token 是目前最流行的跨域认证解决.将token和payload加密后储存在客户端,服务端用密钥解密进行校验.
  用户登录时,服务端认证成功后返回客户端一个jwt.客户端访问受保护的路由或者资源时,需要请求头Authorization字段中使用Bearer模式去添加jwt.
  服务端会检查请求头中Authorization中的jwt信息是否合法
  缺点: 服务器不存储Session状态,因此使用过程中一但JWT签发,到期之前都会有效,除非服务器部署其他逻辑.而且一但泄露,任何人可以拥有该令牌全部权限,因此有效时间应该设置比较短,一些重要权限,需要二次认证.并且为了减少盗用,要使用https协议传输.
  
# OSI 网络分层
  * **应用层** => 是对特定应用的协议(如电子邮件协议、文件传输协议)
  * **表示层** => 设备固有数据格式和网络标准数据格式的转换(接收不同表现形式的信息,如文字流、图像、声音等)
  * **会话层** => 通信管理,负责建立和断开通信连接
  * **传输层** => 管理两个节点之间的数据传输
  * **网络层** => 地址管理与路由选择
  * **数据链路层** => 互连设备之间传送和识别数据帧
  * **物理层** => 0 1

# TCP/IP 网络分层
应用层 传输层 网际层 连接层
# TCP 和 UDP 区别
  tcp: 面向连接、面相字节流、有状态、保证可交付、具备拥塞控制、点对点传播、有序的.
    TCP 链接,源地址,源端口,目的地址,目的端口
  udp: 无连接、面向数据报、无状态、不保证可靠交付、不具备阻塞控制、广播多播、无序的.
# 什么是 http 协议
HTTP 超文本传输协议,一个在计算机世界中两点间传输文字、图片、音频、视频、等超文本数据的约定和规范.
# 什么是 CDN
 CDN: 内容分发网络.突破现实生活中传输距离等无理限制,部署大量高储存高带宽的节点,构建的专用高速传输网络.
 通过全局负载均衡,判断最适合用户的节点.通过 HTTP 缓存技术进行代理,看是否需要源站获取资源.
 # websocket
  针对"请求-应答"的通行模式,全双工通信,支付服务端主动推送的能力,加强了 tcp 的功能,运行在浏览器之中.
# http 和 websocket的异同点
相同: 都是基于TCP的 可靠性传输协议
不同: 1.websocket是双向通信协议,可以双向发送或者接受信息.
      2.websocket需要浏览器和服务器握手建立连接的,http是浏览器向服务器发起链接,服务器预先并不知道这个链接.
联系: websocket建立握手的时候,数据是通过HTTP传输的,建立之后,真正传输的时候不需要HTTP协议的.

# http 常用首部字段
  ## 通用首部字段
    Cache-control 强缓存控制
    Connection 连接管理
    Transfor-Encoding 报文主题的传输编码格式
    Date 创建报文的事件
    Upgrade 升级为其他协议
  ## 请求首部字段
    Host 请求资源所在服务器
    Accept 客户端或者代理能够处理的媒体类型
    If-Match 比较实体标记(Etag)
    If-none-Match
    If-Modified-Since 比较资源更新时间
    User-Agent 客户端信息
  ## 响应首部字段
    Location 重定向 URL
    ETag
    Server
  ## 实体首部字段
  Allow 资源可支持 http 请求方法
  Last-modified 资源最后修改时间
  Expires 实体主体过期时间
  Content-Language 实体资源语言
  Content-Encoding 编码格式
  Content-length 大小
  Content-type 媒体类型
  ## http 的报文请求有那几个部分
  请求行,请求体,数据体,状态行,响应头,响应正文
  ## 预检请求 
  请求方法是 PUT 或 DELETE,或者 Content-type:application/json
  会在正式通信前,进行一次预检请求
  查询服务器支持的 hpttp 方法,和自定义的 header 属性有哪些
  # http 协议头Content-Type和Accept的作用
  Content-Type:发送端发送的数据类型
  Accept:发送端（客户端）希望接受的数据类型
  # Content（发送方）、Accept（接收方）系列字段了解多少
    1.数据格式 Content-type/Accept
    2.压缩方式 Content-Encoding/Accept-Encoding
    3.支持语言 Content-language/Accept-Encoding
  # 如何计算首屏时间和白屏时间
  白屏时间 = domLoading - fetchStart
  domReady可操作时间 = domContentLoadedEventEnd - fetchStart
  onload总下载时间 = loadEventEnd - fetchStart
  # 定长与不定长的数据，http传输
  定长数据： http会指定Content-Length 指定包的长度。短于数据长度会截去数据，长于数据长度会无法展示。
  不定长数据： Transfer-Encoding： chunked
  会忽略Content-Length字段，并基于长连接动态推送数据

  # 关于 http1.1 以及 http2
  http1.1 中浏览器再也不用为每个请求重新发起 TCP 链接,增加了: 缓存相关首部的扩展,OPTIONS 方法,Upgrade 首部,Range 请求,压缩和传输编码,管道化等.
  http2 解决了 http 中队头阻塞的问题(管道化特性可以让客户端一次发送所有的请求,但是有些问题阻碍了管道化的发展.即是某个请求花了很长的时间,那么队头阻塞会影响其他请求).
  ## http1.1
    * 持久链接 (默认开启)
    * 管道化技术 (多个http请求可以批量发送,解决对头阻塞问题.但是会按照发送顺序返回响应)
    * 支持响应分块 (定义Transfer-Encoding将数据拆分成多个模块,产生一块数据就发送一块数据,减少白屏时间)
    * cache-control、e-tag缓存头

  ## http2 
    * 多路复用机制,引入了二进制的分帧层机制来实现多路复用.(分帧层基于帧的二进制协议,这方便了机器的解析,请求和响应交织在一起)
    * 可以设置请求优先级
    * 头部压缩 请求头压缩 增加传输效率.hpack 压缩,对经常使用的头部键值维护一张表,通过索引进行数据关联.分为静态表和动态表
    * 服务器推送 (主动发送资源缓存到客户端中,而且可以在返回html文件的时候主动将js、css文件一起传输给客户端)
    * 流量控制
    * 重置消息

  ### http2 的概念: 

    1. 流: 他是连接中的一个虚拟信道.连接内的双向字节流,可以承载一条或多条数据.
    2. 消息: 一个请求或者响应对应的一个或多个帧.
    3. 帧: 一段二进制数据,他是 http2.0 通信的最小单位.
    
    一个tcp连接上有多个数据流,一个数据流承载着双向信息,一条消息包含了多个帧,每个帧都有唯一的标识,指向所在的数据流.来自不同数据流的帧可以交错发送.然后再根据每个帧的头的数据流标识符重新组装,实现数据传输.
    
  ### http2 多路复用的实现:
    在单个域名下仍可以建立一个 TCP 管道,使用一个 TCP 长连接,下载整个资源页面,只需要一次慢启动,并且避免了竞态,浏览器发起请求,分帧层会对每个请求进行分割,将同一个请求的分割块打上相同的 id 编号,然后通过协议栈将所有的分割体发送给服务器,然后通过服务器的分帧层根据 id 编号进行请求组装,服务器的分帧层将回应数据分割按同一个回应提进行 id 回应给客户端,客户端拼装回应,
  
  ### 消息头为什么需要压缩
    基于 TCP 的慢启动机制,他会基于对已知有多少个包,来确定还要来回去去获取哪些包.使用头部压缩之后,哪些请求只需要一个来回就能搞定.
    拥塞


  使用 http2 会比 http1.1 在使用 TCP 时,用户体验的感知多数延迟的效果有了量化的改善,以及提升了 TCP 链接利用率(并行的实现机制不依赖与服务器建立多个链接)
  对于 http2,可以运行一个 http2 的服务器,获取并安装一个 http2 的 web 服务器,下载并安装一张 TLS 证书,让浏览器和服务器通过 http2 来链接.

    http2的问题: 
    基于tcp传输,那么首先需要优化的就是TCP,因为TCP作用是保证传输层可靠性,但传输效率并不高.
    * TCP也存在队友阻塞,TCP在传输时使用序列号标识数据顺序.一旦某个数据丢失,后面的数据都要等待那个数据重传后下一步处理
    * TCP链接传输需要三次握手,释放连接需要四次挥手,无形中增加传输时长.
    * TCP存在阻塞控制,内置慢启动,传输效率并不高.

  ## http3
    基于UDP进行的多路复用的协议QUIC

  ### QUIC基于UDP怎么保证可靠性
    TCP通过三次握手,给每一份数据包添加序列,以及重试机制,保证可靠性.而QUIC在UDP基础上,增加了一层实现TCP的功能.
  # 为什么说利用多个域名来存储网站资源会更有效？
  CDN 缓存方便、突破浏览器最大 6 个并发限制、节约 cookie 带宽、节约主域名的连接数,优化页面响应书读、防止不必要的安全性问题
  弊端: 浏览器进行 dns 解析也是需要耗费时间的,而且太多的域名在使用 https 请求的时候,需要购买相当数量的证书,耗费大量的金钱
# 前端安全(CSRF、XSS、http 劫持)
CSRF基本概念: 攻击原理,防御措施. 跨站请求伪造.
CSRF 解决方案: 
  1. token 验证
  2. Referer(页面请求来源) 验证.

XSS 基本概念: 跨域脚本攻击.攻击者想尽一切办法将一些可执行的代码注入到网页中.
http 劫持: 电信运营商被劫持
# http 代理
代理服务器功能: 

    1. 负载均衡
    2. 保障安全(利用心跳机制监控服务器)
    3. 缓存代理
    
# http 小结

    1. http 处于 TCP/IP 网络分层模型中第一层,即应用层
    2. http 协议是支持客户端与服务器的模式,一种请求与相应的协议
    3. http 具有灵活可扩展性,传输类型由 Content-Type 控制
    4. 无状态,每一次请求都是独立的
    5. 持久链接,建立一次TCP 链接可以发送多次请求与相应的交互
    6. 只要一方没有断开链接.保持 TCP 链接状态,减少 TCP 链接和断开造成额外的开销
    7. 管道化,同时并行多个请求(chrome 默认同一域名下6个),不用等到前一个请求完毕后才进入下一个请求
  
  其他问题: 

# DNS 预解析
  <link rel="dns-prefetch" href="" />
  Chrome 和 Firefox 3.5+ 能自动进行预解析

# 强缓存和协商缓存
 浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中
 浏览器每次发起请求,会在浏览器缓存中查找该请求的结果已经缓存标识
 浏览器每次拿到返回的请求结果就会将该结果和缓存标识存入浏览器缓存中
 强缓存 
  不需要发送请求到服务端,直接读取浏览器本地缓存.分为 Disk Cache 和 Memory Cache.存放位置由浏览器控制.强缓存由 Pragma、Cache-control、Expires 3 个header 
  Pragma 
   只有一个值 no-cache 不使用强缓存 优先级最高
  Cache-control 
    http1.1 中新增属性 
    max-age:秒 距离发起请求秒数,超过间隔缓存失效
    no-cache 不使用强缓存
    no-store 不使用缓存(包括协商缓存)
    private cdn 中间代理不得缓存
    public 可以被中间代理 cdn缓存
  Expires 
    本地系统时间 超过重新请求
协商缓存
 当强缓存失效了或者设置不走强缓存,并且请求头中设置了 If-Modified-Since 或者 If-no-match 时,
 回去服务端验证是否命中协商缓存.命中了返回 304 加载浏览器缓存.设置 last-modified 或 Etag 属性.
  ETag/if-none-match
  哈希值
  Last-Modified/if-Modified-since
  文件最后修改时间 判断不了一秒之内的修改
协商缓存不像强缓存一样有优先级,一般是配合使用,etag 计算复杂度比 last-Modified 更高,而 last-Modified 不如 etag 精准
## 浏览器缓存资源
webkit资源分为两类:
主资源: html页面,或者下载想
派生资源: html中内嵌图片或者脚本类.用于保存原始数据(css,js)解码过的图片数据
memory cache 和 disk cache
相同点: 只能储存一些派生类资源文件
不同点: memory cache退出进程数据会被清除.
储存资源: 一般脚本、字体、图片会存在内存当中.非内存会存在磁盘中.**css文件加载一次就可以渲染出来,我们不会频繁读取他,所以不适合缓存到内存中.js之类的脚本随时可能会执行,如果脚本在磁盘中,我们执行脚本的时候需要从磁盘渠道内存中,这样IO开销会很大,导致浏览器失去响应**
## 三级缓存原理(访问缓存优先级)
1. 优先内存中查找
2. 硬盘中查找
3. 网络请求
4. 请求获取到的资源缓存到硬盘和内存中

# grpc 相比 http 的优势？
也是使用TCP/IP协议,使用http作为底层传输协议(gRpc使用的是http2.0)
 * grpc通过protobuf(一套类似json规范的传输数据格式,可以在不同进程间使用)定义接口,更加严格的接口约束条件
 * protobuf可以将数据序列化为二进制编码,大幅度减少传输数据量,大付出 提高传输效率
 * grpc支持 http2.0

# https的概念 
客户端发送 协议版本号、随机数(random1)、支持的加密方式 到服务端 
服务端接收到客户端请求,生成公钥和私钥. 向客户端传递公钥 证书 版本 过期时间等信息 服务器生成一个随机数(random2)
客户端拿到证书后解析判断是否合法 不合法直接地址栏提示危险
合法通过(random1 + random2)生成密钥并通过公钥加密并传输给服务端
服务端拿到加密的随机数以后用私钥对解密得到随机数 
之后服务端 客户端用这三个随机数生成加密之后所有的数据传输


# TCP拥塞控制
TCP 协议通过慢启动机制、拥塞避免机制、加减递减机制、快重传、快恢复机制共同实现拥塞控制.
## 拥塞窗口
该窗口由发送方更具当前计算机网络拥塞情况计算,和通知窗口共通作用于发送窗口.拥塞窗口初始值为一个最大 TCP 报文段的大小.
TCP的慢启动、拥塞避免、加速递减都是通过改变拥塞窗口大小来时时对发送方的发送窗口进行控制.

## 拥塞控制与流量控制
拥塞控制是一个全局性控制,设计计算机网络中所有的主机,路由器已经降低网络传输性能的相关因素.而流量控制只涉及到通信双方的收发平衡.
TCP 在控制流量数据传输时,纪要考虑接收端的接受能力,又要避免网络拥塞,因为发送方的发送窗口大小为通知窗口和拥塞窗口的最小值.
## 传输轮次
在 TCP 拥塞避免中,我们规定:每发送拥塞窗口值个数的 TCP 数据段(有效数据承载),并且全部收到发送方对这些数据的 ACK 确认,我们就称完成了一次传输伦次.
eg: 拥塞窗口 = 4,当发送方发送了 4 个 TCP 报文段,并收到了这 4个 TCP 报文段的 ACK 确实,我们就称完成了一个传输伦次.
## 慢启动
慢启动通过逐步增大拥塞窗口的值来控制网络拥塞.
拥塞窗口初始值为 1,每收到一个对发出的数据段的 ACK 确认,便将拥塞窗口的值指数增加 1.
1 -> 2 -> 4 -> 8
随着传输伦次的增加,拥塞窗口值会变得很大,所以 TCP 拥塞控制给慢启动增加一个阈值.随着网络拥塞的出现和变化,阈值也会不断的变化.TCP 拥塞控制中,阈值的初始值为 16.
## 拥塞避免
让拥塞窗口缓慢的变大,呈线性增长,每完成一个传输伦次,拥塞窗口增加 1
## 加速递减机制
如果在使用慢启动或者拥塞避免机制中,发送数据时,出现了定时器超时,便执行加速递减机制.
立刻将慢启动阈值设置为当前拥塞窗口大小,拥塞窗口值重置为 1.立即执行慢启动机制
## 算法判断
拥塞窗口 < 阈值 慢启动算法
拥塞窗口 > 阈值 拥塞避免算法

# 中间人攻击预防方法
1. 针对安全性要求比较高的 app,采取客户端预埋证书的方法锁死证书.只有当客户端证书和服务端证书完全一致才允许通信,如一些银行类的 app.但是当预埋证书过期时,需要强制更新或者要求用户下载证书解决.
2. 针对安全性要求一般的 app,可采用通过校验域名,证书有效期、证书关键信息、证书有效性、证书链的方式.



