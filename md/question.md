# for 循环和 forEach循环,那种性能会更好一点?  
  for循环会更好,没有额外的函数调用栈和上下文. array.forEach(function(currentValue,index,arr),thisValue)
# 什么是 Symbol?
生成一个全局唯一的值.可以用于:作为属性名解决属性名冲突问题、替代代码中多次使用的字符串、作为对象非私有的但希望用于内部的方法
# 如何转换一个类数组对象,原理是什么?
[...objectLikeArray] array.from(objectLikeArray) 
Array.prototype.slice.call(objectLikeArray)
相当于新建了一个数组,从 0 一直取到了最后一项
# Map 和 WeakMap、WeakSet、Set 的区别
  Set 对象可以存储任何类型的数据,值是唯一的,没有重复的值.
  Map 对象保存键值对,能够记住键的原始插入顺序.任何值都可以作为一个键或者一个值.Map对对象是强引用.
  WeakSet 成员只能是对象,不可遍历.
  WeakMap 只接受对象作为键名,不接受其他类型.键名弱引用,键名可以被垃圾回收,此时键名无效.不能被遍历.
# 兼容性问题
  1.样式兼容性  
  > a.reset.css 重置默认样式
    b.webpack 中使用 postCss autoprefixer 给属性加上默认前缀
    c.部分针对功能单独写 (例如透明属性)

  2.交互兼容性
  > 类似 jq,工厂模式,将所有浏览器支持属性写入,判断是否支持该属性,然后使用这个属性去改变.
    例如事件兼容,阻止冒泡,阻止默认行为,scrollTop

  3.浏览器 hack(根据浏览器去做兼容)
# server Worker
# 扫码登录原理
登录页面时,向服务器发送获取登录二维码的请求.
服务器收到请求后,随机生成一个 uuid,将这个 id 存入服务器,设置一个过期时间,若超过过期时间,则需要重新获取二维码
这个 key 生成二维码图片和 uuid返回给浏览器展示.浏览器会不停的轮询,查看登录状态.
移动端 获取到包含用户信息的 token,将 token 作为参数传给服务器发送登录请求.服务求收到后返回确认信息给移动端.内部调用登录方法生成 token 返回给浏览器服务端,浏览器轮询状态变更,登录成功

# Jenkins自动化部署项目
# 如何反爬虫
1. 通过 ua 判断
2. 通过 cookie 平判断
3. 通过访问频率判断
4. 通过验证码判断
5. 动态性页面加载

# EventBus 的设计模式是什么?
1. 首先getDefault 中使用了单例模式,不同线程中只有一个 EventBus 的实例
2. 观察者模式.事件是被观察者,订阅者类是观察者.当事件出现或发生变更的时候,通过 eventBus通知观察者
# 常用设计模式
## 工厂模式
传入参数即可创建实例.(虚拟 dom 根据参数不同返回不同的基础标签)
## 单例模式
整个程序有且仅有一个实例
## 访问者模式
## 观察者模式
## 策略模式
对象某个行为,在不同场景下,该行为有不同的实现方案
# css 对于渲染性能的影响
 css是页面渲染关键因素之一(外链 css),浏览器会等待全部的 css 下载及解析完成后再渲染页面.因而我们需要尽快的将 css 传输到用户设备.
 css 加载过程中不会影响到 dom 树的合成,但会影响到和dom 构建布局树.所以 style link 标签尽量放在 head中,解析 dom 树是自上而下的,css 样式异步加载,使得解析 dom 树和加载 css 样式尽可能并行,加快布局树的生成.

1. 浏览器需要等待 css 转换 styleSheets 创建布局树,分层树后才会开始渲染页面
2. 布局树由 dom 和 styleSheets 计算得到
3. dom 是 html 加上(同步)阻塞的 js 操作(dom 后)的结果
4. styleSheets 是 css 规则应用在dom 树上的
5. js 非阻塞很简单,加上 async 或者 defer 属性即可
6. 理想情况: 最慢的样式表下载时间决定了页面渲染时间

一般情况下,dom 构建可以加快.服务器响应的第一个请求是html 文档,css 一般作为 html 的子资源存在.
## 使用关键 css 
找出首次渲染所需的样式,内联到 head 标签中,其他样式则异步进行加载.
## 使用媒介查询拆分代码
根据媒介查询分优先级
## 不要将动态插入的 js 放在<link>标签后面
在浏览器下载完该 css 文件之前,不会执行下面紧接的 js.
如果<script>中的代码不依赖 css,把它们放在样式表之前.
# export 和 export default 的区别
```js
// export
export let a= 'a'
```
export default 规定模块的默认对外接口,在同一个模块只能出现一次.

# 框架的设计思路
react是一个重运行时的框架,数据变化后通过操作虚拟 dom,帮我们解决跨平台和兼容性的问题,得出最小操作行为.这些全部都是运行时操作的.
vue 保留了虚拟 dom,但是会通过响应式去控制虚拟 dom 的颗粒度,在预编译中,又做了足够多的性能优化,处理了按需加载.
Svelte 是一个重编译的框架,我们只需要写模板和数据.经过 Svelte 的编译和预处理,代码会帮我们解析成原生的 dom 操作(省去虚拟 dom 对比的方法).未使用的功能不会出现在编译后的代码.
SolidJS 类似于 Svelte.通过订阅发布触发响应的 createEffect 回调.执行具体的 dom 方法.内部的状态具有原子性,状态相互之间有依赖关系,形成局部的依赖图.改变一个状态后,依赖图中其他状态也会发生改变.它与 Svelte 最大区别是取消了脏检查.
## 编译时优化
传统 vdom 的 diff 算法总归要按照 vdom 树层级结构一层一层遍历,所有diff 性能会和模板大小成正比.与动态节点的数量无关,在一些组件整个模板内只有少量动态节点的情况下,这些遍历都是性能的浪费.在diff 阶段跳过静态内容,就可以避免无用的 dom 树遍历和对比了.

## 运行时
react 思路纯 js 写法,这种方式非常灵活.但是,这也使他在编译时难做太多的事情.react 优化主要在运行时.例如 fiber 架构空闲帧工作,减少用户对延迟的感知.利用_processPendingState 函数合并 state 暂存队列.最后返回一个合并后的 state.


# 前端性能优化
## 优化渲染位置
1. css、js 的写入位置(css 阻塞html 的渲染和 js 的执行,js 会阻塞 html 的解析和渲染)
2. 延迟加载部分第三方包
## 减少首屏资源大小
3. 资源压缩
4. 减少重排重绘
5. 合理利用路由懒加载
6. 资源在服务端配置开启 gzip
7. 使用 tiny 压缩图片,图片的懒加载
8. 组件库按需加载
9. 使用最新的打包工具
## 减少网络消耗
10. 资源放在 cdn 上,在 cdn 上设置http 缓存(建议只做在cdn上,应用服务器不使用缓存,带 hash 可以加)
11. 资源合并(浏览器最多对同域名进行 6 个请求,公用资源打包合并,不对业务代码合并)
12. 对资源做 preload(提前加载当前页面用到的资源) 和 prefetch(提前加载下个页面用到的资源).
13. 使用多域名进行更多的请求
14. 对域名进行 dns 预解析.

# 向下兼容方案
 1. 通过配置 babel core-js 插件,在 babelrc 配置 preset-env 指定 corejs 代码
 2. 渐进增强和优雅降级
 针对低版本浏览器构建页面保证基础功能的完善.或者构建完成的公司再去针对低版本浏览器兼容.
 ## 兼容性考虑
 1.兼容性: 是否常见语法都能支持兼容转换
 2.易用性: 能够很方便的接入现有开发体系中
 3.通用性和持续性

 # MVVM 框架和 MVC 框架的差别
 基本没差别,唯一的差别是 MVVM 实现了双向绑定
 # 前端线上页面泄漏如何处理?
 performance.memory 监控 totalMemory 和 useMemory

# 对Typescript 的理解
是 js 的一个超集,对 js 语法的扩展,提供了 js 不具备的类型系统和对 ES6 的支持.
是一种静态类型检查的语言,提供了类型注解.在代码编译阶段就可以检查出数据类型的错误.
拥有类型推断、类型批注、接口、模块、泛型、重载等功能.
# react 中难以解决的问题
使用 hooks的闭包的问题,子组件更新导致的父组件更新问题,

# JavaScript 中几种迭代语法在 Chrome 等现代浏览器中的性能差异
for-in 性能明显慢于其他几种循环,每次迭代操作都回去搜索原型或者原型属性,产生额外的开销.
# 如何实现组件拖动
给需要拖动的组件设置draggable属性.
设置onDragStart触发,开始拖动元素触发.
ondrag 元素正在拖动时触发
ondrop 拖动元素放置目标区域触发
ondragend 完成拖动触发
# 虚拟列表滚动过快导致的白屏问题
使用requestAnimationFrame,通过系统决定调用的时机.保证每次页面更新的时候只执行一次.不会丢帧的情况发生

# js 上传功能
在input type 为 file, js onchange 事件下,能获取到 files 属性.将读取到的 file对象封装成 formData 对象.多个文件的话则需要循环 files 让formData 对象 append 进去.



# 前端工程化的理解
就是将我们的前端项目进行一个分析、,上去达到提高效率、降低成本、保证质量.通过一系列上的规范、流程、工具打到研发提效、自动化、保障质量、服务稳定、预警监控等等.工程化是对项目的整体规划和架构.工具只是实现这种规划和架构的手段.功能上细分可以是: 开发、构建、部署、性能和一个规范化上.
# 页面加载慢问题定位
1. newwork 资源请求
2. webpack-bundle-analyzer 查看 boundle 模块大小.减小加载时长
3. 去看 performance 模块.查看网页性能指标.首次有内容渲染、最大内容绘制时间、fps 是否正常
4. 查看 performanceNavigationTiming 各个阶段的响应时间.确认加载卸载文档用时