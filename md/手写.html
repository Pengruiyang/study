<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body></body>
</html>
<script>
  // ## 数据格式转化
  // const A = [
  //   { id: 1 },
  //   { id: 2, parentId: 1 },
  //   { id: 3, parentId: 1 },
  //   { id: 4, parentId: 2 },
  //   { id: 5, parentId: 3 },
  //   { id: 6, parentId: 3 },
  // ]
  // let mapper = {}
  // let ans = null
  // function createTree(A) {
  //   for (const a of A) {
  //     mapper[a.id] = a
  //     a.children = []
  //     if (!a.parentId) {
  //       ans = a
  //     } else {
  //       if (!mapper[a.parentId]) {
  //         mapper[a.parentId] = {
  //           id: a.parentId,
  //           children: [],
  //         }
  //       }
  //       mapper[a.parentId].children.push(a)
  //     }
  //   }
  // }
  // createTree(A)
  // console.log(mapper)
  // console.log(ans)

  // 并发控制器
  class Queue {
    constructor() {
      this._queue = []
    }
    push(value) {
      return this._queue.push(value)
    }
    shift() {
      return this._queue.shift()
    }
    isEmpty() {
      return this._queue.length === 0
    }
  }

  class DelayedTask {
    constructor(resolve, fn, args) {
      this.resolve = resolve
      this.fn = fn
      this.args = args
    }
  }
  class TaskPool {
    constructor(size) {
      // 任务池工作状态
      this.size = size
      // 队列
      this.queue = new Queue()
    }
    /**
     * 将新任务放入队列中,触发任务池检测机制,如果当前任务池不满的话,则从队列中取出任务放到任务池中执行
     */
    addTask(fn, args) {
      return new Promise((resolve) => {
        this.queue.push(new DelayedTask(resolve, fn, args))
        if (this.size) {
          this.size--
          const { resolve: taskResole, fn, args } = this.queue.shift()
          taskResole(this.runTask(fn, args))
        }
      })
    }
    // 如果当前队列不为空,任务池不满,主动执行任务
    pullTask() {
      if (this.queue.isEmpty()) return
      if (this.size === 0) return
      this.size--
      const { resolve, fn, args } = this.queue.shift()
      resolve(this.runTask(fn, args))
    }
    // 执行当前任务,任务执行后更新状态,主动拉取任务执行
    runTask(fn, args) {
      const result = Promise.resolve(fn(...args))
      result
        .then(() => {
          this.size++
          this.pullTask()
        })
        .catch((err) => {
          this.size++
          this.pullTask()
        })
      return result
    }
  }

  const taskList = [3000, 200, 1000, 1300, 800, 2000]

  // 需要队列

  const task = (timeout) =>
    new Promise(
      (resolve) =>
        setTimeout(() => {
          console.log(timeout)
          resolve(timeout)
        }, timeout)
      // {
      //   console.log(timeout)
      //   return resolve(timeout)
      // }
    )
  const cc = new TaskPool(2)
  // async function startNoConcurrentControl() {
  //   await Promise.all(taskList.map((item) => cc.addTask(task, [item])))
  // }
  async function start() {
    console.time('aa')
    await Promise.all(taskList.map((i) => cc.addTask(task, [i])))
    console.timeEnd('aa')
  }
  start()

  // Promise
  function Promise1(func) {
    this.fullfilled = false
    this.rejected = false
    this.pending = false
    this.handles = []
    this.errHandles = []
    function resolve(...args) {
      this.handles.forEach((handle) => handle(...args))
    }
    function reject(...args) {
      this.errHandles.forEach((handle) => handle(...args))
    }
    func.call(this, resolve.bind(this), reject.bind(this))
  }
  Promise1.prototype.then = function (func) {
    this.handles.push(func)
    return this
  }
  Promise1.prototype.catch = function (func) {
    this.errHandles.push(func)
    return this
  }
  Promise1.all = (promises) => {
    return new Promise1((resolve, reject) => {
      let len = promises.length
      let res = []
      promises.forEach((promise, i) => {
        promise.then((r) => {
          if (len === 1) {
            resolve(res)
          } else {
            res[i] = r
          }
          len--
        }, reject)
      })
    })
  }
  Promise1.race = (promises) => {
    return new Promise1((resolve, reject) => {
      promises.forEach((promise) => promise.then(resolve, reject))
    })
  }

  // 继承
  function initPrototype(A, B) {
    // 复制父节点的原型对象
    let prototype = Object.create(A.prototype)
    // 指向新建的子类
    prototype.constructor = B
    // 完成prototype的与子类链接
    B.prototype = B
  }

  function A(name) {
    this.name = name
    this.list = [1, 2, 3]
  }
  A.prototype.say = function () {
    alert(this.name)
  }
  function B(name, age) {
    A.call(this, name)
    this.age = age
  }
  initPrototype(A, B)

  // new
  function _new(fn, args) {
    let obj = Object.create(fn.prototype)
    let ret = fn.call(obj, ...args)
    return ret instanceof Object ? ret : obj
  }
  // bind

  const myBind = (ctx,...args) => {
    return (...nextArgs) => {
      this.call(ctx,...args,...nextArgs)
    }
  }
  // curry
  function curry(fn) {
    const inner = (...args) => {
      console.log(args)
      if (fn.length === args.length) {
        return fn.call(this, ...args)
      }

      return (...innerArgs) => inner.call(this, ...args, ...innerArgs)
    }
    return inner
  }
  function test(a, b, c) {
    console.log(a, b, c)
  }
  const f1 = curry(test)(1)(2)(3)
  console.log(f1)
  // pipe
  const pipe = (...args) => (x) => args.reduce((v, fn) => fn(v), x)
  //实现destructuringArray方法，达到如下效果
  function destructuringArray(array, formatter) {
    const parse = (str) => {
      return JSON.parse(str.replace(/\w+/g, '"$&"'))
    }
    const formatterArr = parse(formatter)

    const fn = (value, key, result = {}) => {
      if (Array.isArray(key)) {
        let newResult = { ...result }
        key.forEach((i, index) => {
          newResult = fn(value ? value[index] : undefined, i, newResult)
        })
        return newResult
      }
      return {
        ...result,
        [key]: value,
      }
    }
    return fn(array, parse(formatter))
  }

  // console.log(destructuringArray([1, [2, 4], 5], "[a ,[b],c,d]"));

  // 深度对比两个对象是否相等
  // const isEqual = function (oldData, newData) {
  // const isEqual = (oldData, newData) => {
  //   // 简单类型直接判断 或者指针一样
  //   if (oldData === newData) return true
  //   const args = Array.prototype.slice.call([oldData, newData])
  //   // const args = Array.prototype.slice.call(arguments)
  //   const objCall = (obj, string) => Object.prototype.toString.call(obj) === `[object ${string}]`
  //   if (args.every(obj => objCall(obj, 'Object')) && Object.keys(oldData).length === Object.keys(newData).length) {
  //     for (const key in oldData) {
  //       //hasOwnProperty
  //       if (oldData.hasOwnProperty(key) && !isEqual(oldData[key], newData[key])) {
  //         return false
  //       }
  //     }
  //   }
  //   else if (args.every(obj => objCall(obj, 'Array')) && oldData.length === newData.length) {
  //     for (const key in oldData) {
  //       if (!isEqual(oldData[key], newData[key])) {
  //         return false
  //       }
  //     }
  //   } else {
  //     return false
  //   }
  //   return true;
  // }
  const isEqual = (oldData, newData) => {
    const oldKeys = Object.keys(oldData)
    const newKeys = Object.keys(newData)
    if (oldKeys.length !== newKeys.length) {
      return false
    } else {
      for (const key in oldData) {
        if (!newData.hasOwnProperty(key)) return false
        // 类型相同
        if (typeof oldData[key] === typeof newData[key]) {
          // 都是引用类型
          if (typeof oldData[key] === 'object') {
            if (!isEqual(oldData[key], newData[key])) {
              return false
            }
          }
          if (
            typeof oldData[key] !== 'object' &&
            oldData[key] !== newData[key]
          ) {
            return false
          }
        } else {
          return false
        }
      }
    }
    return true
  }
  // console.log(isEqual({ a: 1, b: [1, 2], c: { d: 1 } }, { a: 1, b: [1, 2], c: { d: 1 } }), 'isEqual322');

  // 合并有效数组
  const merge = function (num1, m, num2, n) {
    let len = m + n
    while (m > 0 && n > 0) {
      num1[--len] = num1[m - 1] > num2[n - 1] ? num1[--m] : num2[--n]
    }
    if (n > 0) {
      num1.splice(0, n, ...num2.splice(0, n))
    }
  }
  // 反转列表
  var reverseList = function (head) {
    let [p, cur] = [null, head]
    //  链表的交换需要扩展一个指针 即next
    // cur 当前项
    // prev 上一项
    while (cur) {
      ;[cur.next, prev, cur] = [prev, cur, cur.next]
    }
    return prev
  }
  // 求数组里面最大连续项的和
  function getMaxSum(arr) {
    let dp = Array(arr.length).fill(0)
    let maxSum = 0
    dp[0] = arr[0]
    for (let i = 1; i < arr.length; i++) {
      dp[i] = Math.max(arr[i], dp[i - 1] + arr[i])
      if (dp[i] > maxSum) {
        maxSum = dp[i]
      }
    }
    return maxSum
  }
  // console.log(getMaxSum([1, -2, 3, 4, -1, 5]),'getMaxSum');

  //求一个数组最大子项的和，要求这些子项在数组中的位置不是连续的。
  var rob = function (nums) {
    if (nums.length === 0) return 0
    if (nums.length === 1) return nums[0]
    let dp = Array(nums.length)
    dp[0] = nums[0]
    dp[1] = Math.max(dp[0], nums[1])
    for (let i = 2; i < nums.length; i++) {
      dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
    }
    return dp[nums.length - 1]
  }

  // 发布订阅模式
  class EventEmitter {
    constructor() {
      this.events = {}
    }
    // 订阅事件方法
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = [callback]
      } else {
        this.events[eventName].push(callback)
      }
    }
    // 触发事件
    emit(eventName) {
      this.events[eventName] && this.events[eventName].forEach((cb) => cb())
    }
    once(eventName, callback) {
      let fn = () => {
        cb()
        this.remove(eventName, callback)
      }
      this.on(eventName, fn)
    }
    //
    remove(eventName, calllback) {
      if (this.events[eventName]) {
        this.events[eventName] = this.events[eventName].filter(
          (cb) => cb != calllback
        )
      }
    }
  }

  // 观察者模式
  class Publish {
    constructor() {
      this.observersList = []
    }
    addObserver(targetType, observer) {
      if (!this.observersList[targetType]) {
        this.observersList[targetType] = [observer]
      } else {
        this.observersList[targetType].push(observer)
      }
    }
    removeObserver(targetType, observer) {
      let observers = this.observersList[targetType]
      if (!observers) {
        return false
      }
      if (!observer) {
        observers.length = 0
      }
      observers = observers.filter((cb) => cb != observer)
    }
    publish() {
      // let [..._arguments] = arguments
      let targetType = Array.prototype.slice.call(arguments)
      let observers = this.observersList[targetType]
      if (!observers || observers.length === 0) {
        return
      }
      observers.forEach((observer) => {
        observer.receive(targetType)
      })
    }
  }
  class Observer {
    constructor(name) {
      this.name = name
    }
    receive(targerType) {
      console.log(this.name + '收到' + targerType + '类型更新的消息！')
    }
  }
  let phonePublish01 = new Publish()
  // phonePublish01.addObserver('小米12', new Observer('订阅者01'))
  // phonePublish01.addObserver('红米12', new Observer('订阅者02'))
  // phonePublish01.publish('小米12', '黑色款小米12')

  // sleep 实现
  function sleep(delay) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve()
      }, delay * 1000)
    })
  }
  // Parameters
  // type Parameters<T extends (...args:any)=>any> = T extends (...args: infer P) =>any ? P :never

  var searchRange = function (nums, target) {
    const binarySearch = (nums, target, isLeft) => {
      let left = 0,
        right = nums.length - 1,
        ans = nums.length
      while (left <= right) {
        const mid = Math.floor((left + right) / 2)
        if (nums[mid] > target || (isLeft && nums[mid] >= target)) {
          right = mid - 1
          ans = mid
        } else {
          left = mid + 1
        }
      }
      return ans
    }
    console.log(nums, 'nums')
    let ans = [-1, -1]
    let leftIndex = binarySearch(nums, target, true)
    let rightIndex = binarySearch(nums, target, false) - 1
    console.log(leftIndex, 'leftIndex')
    console.log(rightIndex, 'rightIndex')
    if (
      leftIndex <= rightIndex &&
      rightIndex < nums.length &&
      nums[leftIndex] === target &&
      nums[rightIndex] === target
    ) {
      ans = [leftIndex, rightIndex]
    }
    return ans
  }
  // searchRange([5,7,8,8,9],7)

  // 模板字符串实现
  const strModal = (str) => {
    let reg = /\$\{(\w+)\}/g
    str = str.replace(reg, function (x, y) {
      console.log(x, 'x')
      console.log(y, 'y')
      return eval(y)
    })
    return str
  }
  let name = '长城软件',
    age = 40
  let str = 'hello~~${name}风风雨雨走过了${age}载'
  // strModal(str)
  // co 函数实现
  function coSimple(gen, ...args) {
    gen = gen.apply(this, args)
    return new Promise((resolve, reject) => {
      // 初始化入口函数
      onFulfilled()
      // 成功状态下回调
      function onFulfilled(res) {
        // 拿到第一次 yeid
        const ret = gen.next(res)
        next(ret)
      }
      function onRejected(err) {
        const ret = gen.throw(err)
        next(ret)
      }
      function next(ret) {
        const promise = ret.value
        promise && promise.then(onFulfilled, onRejected)
      }
    })
  }

  // 洋葱模型核心 compose
  function compose(middlewares) {
    return (ctx) => {
      const dispatch = (i) => {
        const middleware = middlewares[i]
        if (i === middlewares.length) {
          return
        }
        return middleware(ctx, () => dispatch(i + 1))
      }
      dispatch(0)
    }
  }

  // 随机的取出 m 个 数

  function getRandomArrayElements(arr, count) {
    let newArr = arr.slice(0),
      length = arr.length,
      min = length - count,
      temp,
      index = 0
    while (length-- > min) {
      index = Math.floor((length + 1) * Math.random())
      temp = newArr[index]
      newArr[index] = newArr[length]
      newArr[length] = temp
    }
    return newArr.slice(min)
  }

  var items = ['1', '2', '4', '5', '6', '7', '8', '9', '10']

  // console.log(getRandomArrayElements(items, 4))

  // 快排
  function quickSort(arr) {
    if (arr.length < 2) return arr
    let middleIndex = Math.floor(arr.length / 2)
    let middle = arr.splice(middleIndex, 1)
    let left = [],
      right = []
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] < middle) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }
    return quickSort(left).concat(middle, quickSort(right))
  }
  // 节流
  function throttle(fn, time) {
    let flag = true,
      timer = null
    return (...args) => {
      if (!flag) return
      flag = false
      setTimeout(() => {
        fn.apply(this, args)
      }, time)
    }
  }
  // 防抖
  function debounce(fn, time) {
    let timer = null
    return (...args) => {
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        fn.apply(this, args)
      }, time)
    }
  }
  //实现一个 useState
</script>
