# 如何设计一个项目
    1. 向需求看齐.深入需求理解业务.考虑实际需要和未来发展.(项目背景、当前业务和其他业务关联及它所处在的位置、用户群体、设设计的业务)
    2. 降低成本. 开发成本、维护成本、时间精力等.让开发过程中只需要专注业务,其他目录、打包、发布、及其他特定功能 (目录构建、自动化构建、基础组件抽离)
    3. 适合解决问题的技术. (pc端还是移动端,或者多端? 用户规模、toB or toC、技术上手成本、满足业务需求、技术本身的稳定性)
# 介绍自己的项目
## 项目背景
    随着公司发展，之前已有的权限中心不能满足现有业务发展。之前权限中心负责配置、校验、授权一个子系统的权限。授权架构采用了租户隔离，组织隔离。每一个权限实体（员工），必须包含于一个租户和组织。接入了有菜单权限、网关权限、数据权限等。
    1. 权限由权限负责人配置权限，业务实际场景复杂，配置需要了解更新多变业务场景。
    2. 之前菜单权限与数据权限统一绑定在用户角色上，部分数据差异导致角色无意义增加，角色越趋累赘。而删除数据时，发现角色和数据交织重复无法彻底删除。

    针对这些问题，
## 基本介绍
* 基础权限: 菜单导航栏 & 二级子路由 & 按钮权限
* 数据权限: 页面上数据展示
## 项目目标
    网上查询了很多相关权限管理项目，但是项目与自身业务息息相关，所以能借鉴的很有限。
## 边界值考虑
    1. 新老项目交替时数据存储问题
    2. 新项目对老项目兼容问题
    3. 新项目数据结构对其他域兼容问题 
## 权限架构和模型
### 老架构
租户层： 谊品生鲜、谊品城配、谊品到家
主体层： 客户    |  商户    |    员工
角色层： 城配客户|  营业部、供应商 |  区长、店长...
系统层： 城配app、城配小程序 | 商户中心、采购中心 | 订单中心、城配后台、数据中心...
权限层： 登录系统、浏览商品、下单.......

### 老模型
```
                                    组织 ==============1： n============== 身份
                                    ||                                  / ||
                                    ||                               /    ||
                                    n：n                         n:n      1:1
                                    ||                          /         ||
                                    ||                        /           ||
租户(生鲜/到家/城配)==1:n==用户==1:n==主体（商户、员工）                角色==n:n==权限
```

## 前端架构部分
### 权限设计了解
1、ABAC设计本质
ABAC设计是为了满足控制请求者在某些条件下是否对请求数据具备某个操作(API)的能力.
### 架构原则
    1. 向需求看齐
    2. 降低成本(目录、打包、发布等)
    3. 合适的解决方案

## 菜单权限
1. 路由权限
    跳转页面时,会去请求当前域拥有的全部菜单权限.不存在则返回当前页面 / 默认页面


# 设计原则
前端抽离组件库原则
## 抽离通用样式组件(样式重构)
1.颗粒度考量.从单一职责原则出发,将组件分为基础/样式组件和容器/符合组件.
一个组件专注的做一件事,尽可能复用组件.
不可以复用的单一职责组件我们就仅仅作为内部独立组件.
2. 通用性考量 不同于业务组件,内部与业务解耦.参考 Antd 组件设计,将 dom 基本结构控制权全部暴露给使用者,只负责底层逻辑和最基本你的 dom 结构.仅仅只保留默认结构
3. 技术选型 使用 css-in-js 方案, 考虑.jsx 将 js 和 html 整合到组件中,这时,我们从组件维度出发,不分离 css, 组件的样式应当跟着组件走.使用 styled-components.
4. 技术选型 js 依旧保持已有 ts 模式.
5. 打包工具: rollup、webpack、vite,适用性,稳定还是选择了 webpack.
6. 代码检测.eslint 按照之前以后项目开发风格,从公司大家习惯照旧吧.没必要改变.commit 规范同eslint.
### styled-componentds 好处
1. 基于标准 css 预发出发,支持less 嵌套、变量的常用语法.学习成本低
2. 支持全局 css 覆盖
3. 支持自定义 className
4. 当需求需要 css + js 动态组合完成的情况.之后需求变更原先 css 已有的样式变更太麻烦了.

## 开发命令行工具

# gitlab CI
gitlab 集成的工具,在仓库根目录下创建.gitlab-ci.yml 文件.配置 gitlabRunner,提交时,gitlab 自动识别.gitlab-ci.yml 文件.使用 gitlab Runner 执行该脚本.
# 自我介绍
上家就职于谊品生鲜这家公司,我们拥有线上2C到家业务、线下新零售生鲜门店、商品2B城配的业务线.拥有采购、物流、仓储、履约、核销、销售等方面.我们公司基础数据分为权限、商户、商品中心三块底层数据.而我负责的是权限中心和商户中心的一个子版块商家中心.包括日常需求的评审,开发、功能优化、组件封装等.首先商户中心的功能主要是给员工或者商家进行一个账户、角色、数据权限、菜单权限、菜单按钮权限等功能的一个配置,简单来说就是配置子系统权限.而商家中心,商家对我们公司的概念就是一个供货商.商家中心就是针对这些用户的一个小中台.主要功能有关于不同业态下的商家入驻功能、商家信息变更、商家公告、商家活动定制推广等功能.技术栈主要是是一个基于 react16.8(hooks 写法) 全家桶 + ts + antd(4.0) + webpack(4.0).我负责期间.完成了两次 UI 重构和一次代码架构升级.
封装业务组件,组件耦合业务功能,提升减少日常开发代码量.日常工作开发脚本和 chrome 插件,提升工作工作效率.

##
上家公司就职于常桥科技，主要是做海外金融证券的一家公司，持有香港、新西兰、新加坡拍照。产品 Longbridge有 网页版、应用端、apps三端。我们证券相比富途、微牛这类证券，我们产品会更加为用户去贴近新型的互联网证券服务，在证券功能上 添加更多类似于直播、评论、社交型功能。桌面端分为tob面向用户，toC面向交易员两块。而我负责的主要应用端个股和行情模块，行情包括的股票的图表模块，分时图、K线走势和各种指标展示。包括盘口的一些数据展示，股票盘口指标等功能、订单模块、股票的交易、异常订单的处理、补单功能等等。而自己负责的业务之外，日常还需要去迭代一些桌面应用的基础功能，如果指标自定义表格，表头拖拽、使用原生系统Menu去替代一些下拉组件的使用、toC面向交易员导致交易功能全局快捷键的支持等等-+
。技术栈是electron15 + vue3.0 + vuex + webpack4 + tailwindCss + sentry错误日志上报.我们没有使用其他的组件库，所有的组件都是我们自己封装开发。
开发流程是一个上一次需求迭代进入集成测试期间进行下一个版本的需求分配，自己产出技术分档去定制一个开发计划。上一个需求迭代完成后进入项目总结阶段，同时进入下一个迭代周期。进入开发阶段，将自己每天完成的功能让别人进行code review进入dev分支。每天早上的晨会进行一个项目进度的把控。
# 微前端
微前端分为主应用和子应用,主应用也被称为基座应用.是其他应用的容器载体.
基于监听 url 的 change 事件,在路由变化时匹配到渲染的子应用并进行渲染.
同时暴露出初始化、渲染和卸载三个方法.
mircroApp 类 webComponents + HTML entry
web原生组件，它有两个核心组成部分：CustomElement和ShadowDom。CustomElement用于创建自定义标签，ShadowDom用于创建阴影DOM，阴影DOM具有天然的样式隔离和元素隔离属性。由于WebComponent是原生组件，它可以在任何框架中使用，理论上是实现微前端最优的方案。但WebComponent有一个无法解决的问题 - ShadowDom的兼容性非常不好，一些前端框架在ShadowDom环境下无法正常运行，尤其是react框架。
通过设置 html 作为资源入口,远程加载 html.解析器 dom 结构从而获取 js、css 等静态资源来实现微前端的渲染.
用 CUstomElement 结合自定义的 shadowDom 实现 webComponent 的功能.
渲染流程:
1. 执行卸载生命周期函数,发送卸载事件,同时清理子应用的全局副作用函数.
2. 监听元素被渲染,加载子应用的 html 并转换为 dom.递归查询所有静态资源并设置元素隔离.拦截所有动态创建的 script link 标签.将加载的 js 通过插件系统后放入沙箱处理.最终将格式化后的元素放入 micro-app 中,这个元素就是子应用.

#shadowDom 的实现
var oBox = document.querySelector('#Box');
// 创建 shadow DOM
var shadowRoot = oBox.createShadowRoot();
shadowRoot.innerHTML = 'JavaScript';
var template = document.querySelector('.Box-template');

shadowRoot.appendChild(document.importNode(template.content,true));

首先我们选取了一个id是Box的元素作为宿主对象（shadow host），然后使用createShadowRoot()方法给宿主对象增加了一个shadow root的新节点，影子根节点作为影子树的第一个节点，其他的节点都是它的子节点。

我们使用一个模板标签来创建Shadow DOM中的元素，取代使用繁琐的原生方法。而templete中的标签作为一个插入点，

在使用多个插入点时，由于每个定义的字段都需要特定的内容，所以我们使用select属性告诉  标签有选择性的插入内容。select属性使用 CSS 选择器来选取想要展示的内容。也就是说，会在影子宿主里寻找任何样式名称 html的元素。如果找到一个匹配的元素，其就会将这个元素渲染到shadow DOM中对应的标签中去。

通过插入点，我们不必修改 content 内容的结构而改变渲染的顺序。因为内容存在于影子宿主中，而呈现的方式存在于影子根也就是 shadow DOM 中。

通交换templete中的select值，我们得到了一组重排的数据。

