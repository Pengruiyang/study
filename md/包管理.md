# pnpm的优势
不需要考虑拍平算法(深度遍历所有包,去决定那个包提升到最上面那一层,而且很不稳定).
node_modules下只有express,没有幽灵依赖.所有依赖在.pnpm里面铺平从全局store硬链接过来,包与包之间的关系通过软连接组织在一起.
## 为什么要使用硬链接,而不是全部使用软连接
一个包在同一台机器上可以有不同的依赖集
在项目A中foo@1.0.0可以具有一个依赖被解析为bar@1.0.0,但是在项目b中foo的依赖可能会被解析至bar@1.1.0.因此,pnpm硬链接foo@1.0.0到每个使用他的项目,以便为其创建不同的依赖集.
## 幽灵依赖
没有声明在dependencies里面的依赖,由于早期会把依赖铺平导致代码中可以直接require进来依赖的依赖.
## 软连接和硬链接
1. 软连接可以理解为指向源文件的指针,他是一个单独的文件,仅仅拥有几个字节,属于自己的 inode
2. 硬链接与源文件同时指向一个物理地址,他与源文件共享储存数据,拥有共同的 inode.硬链接或者源文件任意之一被删除,实体文件不会被删除.硬链接文件就是文件的另一个入口
## pnpm 为何节省空间
 1. 解决了npm/yarn 平铺 node_modules 带来的依赖项重复的问题.
 2. 而在 pnpm 中,改变了目录结构,采用了软连接的方式,避免了重复依赖项的问题.
# learn
## learn 中主要命令 bootstrap 和 learn publish
bootstrap将 repo 中的依赖项链接在一起,publish帮助发布任何更新的包
## 其他命令
run: 执行所有子项目中npm script 脚本
add: 本地远程的包作为依赖关系添加至当前包管理中
## 遇到的问题
1. 第一次发布时需要配置publishConfig:{access: 'public'}
2. independent模式未生效,配置了conventionalCommits
3. npm发布失败,git先提交了没有回滚机制,只能手动 publish
  